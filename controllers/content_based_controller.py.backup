"""
Content-Based Filtering Controller
Handles content-based recommendation logic and exercise similarity calculations
"""

import logging
from typing import Dict, List, Optional
from flask import current_app

from ..services.auth_service import AuthService
from ..services.content_service import ContentService
from ..models.database_models import Recommendations

logger = logging.getLogger(__name__)


class ContentBasedController:
    """Controller for content-based recommendation operations"""

    def __init__(self):
        """Initialize content-based controller with required services"""
        self.auth_service = AuthService()
        self.content_service = ContentService()

    def get_content_similarity(self, data: Dict) -> Dict:
        """Calculate content similarity between exercises"""
        try:
            exercise1_name = data.get('exercise1_name')
            exercise2_name = data.get('exercise2_name')
            similarity_metric = data.get('similarity_metric', 'cosine')

            if not exercise1_name or not exercise2_name:
                return {'error': 'Both exercise1_name and exercise2_name are required'}, 400

            # Get content-based model
            content_model = current_app.model_manager.get_content_based_model()
            if not content_model:
                return {'error': 'Content-based model not available'}, 503

            # Calculate similarity
            similarity_score = content_model.calculate_similarity(
                exercise1_name=exercise1_name,
                exercise2_name=exercise2_name,
                similarity_metric=similarity_metric
            )

            return {
                'status': 'success',
                'exercise1_name': exercise1_name,
                'exercise2_name': exercise2_name,
                'similarity_score': similarity_score,
                'similarity_metric': similarity_metric
            }

        except Exception as e:
            logger.error(f"Content similarity calculation error: {e}")
            return {'error': str(e)}, 500

    def get_user_recommendations(self, user_id: int, data: Dict = None) -> Dict:
        """Get content-based recommendations for user"""
        try:
            num_recommendations = data.get('num_recommendations', 10) if data else 10
            auth_token = data.get('auth_token') if data else None

            # Get content-based model
            content_model = current_app.model_manager.get_content_based_model()
            if not content_model:
                return {'error': 'Content-based model not available'}, 503

            # Get user preferences from auth service (with token)
            user_data = None
            if auth_token:
                user_data = self.auth_service.get_user_profile_with_token(user_id, auth_token)

            if not user_data:
                # Fallback: use basic user preferences
                user_data = {'preferences': {}}

            # Get real exercise data from content service
            exercise_data = None
            if auth_token:
                exercise_data = self.content_service.get_exercise_attributes_with_token(auth_token)

            # Get user-based recommendations
            recommendations = content_model.get_user_recommendations(
                user_preferences=user_data.get('preferences', {}),
                num_recommendations=num_recommendations
            )

            # If we have real exercise data, replace mock recommendations with real ones
            if exercise_data and len(exercise_data) > 0:
                logger.info(f"Using real exercise data: {len(exercise_data)} exercises")
                # Replace mock recommendations with real exercise data
                real_recommendations = []
                for i, rec in enumerate(recommendations[:num_recommendations]):
                    if i < len(exercise_data):
                        real_exercise = exercise_data[i]
                        real_rec = {
                            'exercise_id': real_exercise.get('exercise_id', i + 1),
                            'exercise_name': real_exercise.get('exercise_name', f'Exercise {i + 1}'),
                            'target_muscle_group': real_exercise.get('target_muscle_group', 'core'),
                            'difficulty_level': max(1, real_exercise.get('difficulty_level', 1) + 1),  # Convert 0-based to 1-based (1-3)
                            'duration_seconds': real_exercise.get('default_duration_seconds', 20),  # Use actual duration from DB
                            'calories_per_minute': max(1, real_exercise.get('estimated_calories_burned', 2)),  # Use actual calories from DB
                            'equipment_needed': real_exercise.get('equipment_needed', 'bodyweight'),
                            'recommendation_type': 'content_based_user',
                            'preference_score': rec.get('preference_score', 0.8)
                        }
                        real_recommendations.append(real_rec)
                    else:
                        real_recommendations.append(rec)
                recommendations = real_recommendations
                logger.info(f"Replaced with {len(real_recommendations)} real exercise recommendations")
            else:
                logger.warning("No real exercise data available, using model defaults")

            # Transform recommendations to match client interface
            transformed_recommendations = []
            for rec in recommendations:
                transformed_rec = {
                    'workout_id': rec.get('exercise_id', 1),  # Use exercise_id as workout_id for now
                    'exercise_id': rec.get('exercise_id', 1),
                    'exercise_name': rec.get('exercise_name', 'Unknown Exercise'),
                    'recommendation_score': rec.get('preference_score', 0.8),
                    'content_based_score': rec.get('preference_score', 0.8),
                    'collaborative_score': 0.0,
                    'algorithm_used': 'content_based',
                    'recommendation_reason': f"Content-based recommendation for {rec.get('target_muscle_group', 'fitness')} exercises",
                    'difficulty_level': rec.get('difficulty_level', 2),
                    'target_muscle_group': rec.get('target_muscle_group', 'core'),
                    'default_duration_seconds': rec.get('duration_seconds', 20),
                    'estimated_calories_burned': rec.get('calories_per_minute', 5) * max(1, (rec.get('duration_seconds', 20) / 60)),
                    'equipment_needed': rec.get('equipment_needed', 'bodyweight'),
                    'exercise_category': 'tabata'
                }
                transformed_recommendations.append(transformed_rec)

            # Save recommendations to database
            self._save_recommendations(user_id, transformed_recommendations, 'content_based')

            return {
                'status': 'success',
                'user_id': user_id,
                'recommendations': transformed_recommendations,
                'count': len(transformed_recommendations),
                'algorithm': 'content_based'
            }

        except Exception as e:
            logger.error(f"Content-based user recommendations error: {e}")
            return {'error': str(e)}, 500

    def get_exercise_similarity(self, data: Dict) -> Dict:
        """Calculate similarity between two exercises"""
        try:
            exercise1_name = data.get('exercise1_name')
            exercise2_name = data.get('exercise2_name')
            similarity_metric = data.get('similarity_metric', 'cosine')

            if not exercise1_name or not exercise2_name:
                return {'error': 'Both exercise1_name and exercise2_name are required'}, 400

            # Get content-based model
            content_model = current_app.model_manager.get_content_based_model()
            if not content_model:
                return {'error': 'Content-based model not available'}, 503

            # Calculate similarity
            similarity_score = content_model.calculate_similarity(
                exercise1_name=exercise1_name,
                exercise2_name=exercise2_name,
                similarity_metric=similarity_metric
            )

            return {
                'status': 'success',
                'exercise1_name': exercise1_name,
                'exercise2_name': exercise2_name,
                'similarity_score': similarity_score,
                'similarity_metric': similarity_metric
            }

        except Exception as e:
            logger.error(f"Exercise similarity calculation error: {e}")
            return {'error': str(e)}, 500

    def get_similar_exercises(self, data: Dict) -> Dict:
        """Get similar exercises based on exercise name"""
        try:
            exercise_name = data.get('exercise_name')
            threshold = float(data.get('threshold', 0.7))
            similarity_metric = data.get('similarity_metric', 'cosine')

            if not exercise_name:
                return {'error': 'exercise_name is required'}, 400

            # Get content-based model
            content_model = current_app.model_manager.get_content_based_model()
            if not content_model:
                return {'error': 'Content-based model not available'}, 503

            # Get similar exercises
            similar_exercises = content_model.get_similar_exercises(
                exercise_name=exercise_name,
                threshold=threshold,
                similarity_metric=similarity_metric
            )

            return {
                'status': 'success',
                'exercise_name': exercise_name,
                'threshold': threshold,
                'similar_exercises': similar_exercises,
                'count': len(similar_exercises),
                'similarity_metric': similarity_metric
            }

        except Exception as e:
            logger.error(f"Similar exercises retrieval error: {e}")
            return {'error': str(e)}, 500

    def get_model_health(self) -> Dict:
        """Get content-based model health status"""
        try:
            content_model = current_app.model_manager.get_content_based_model()
            if not content_model:
                return {
                    'status': 'unhealthy',
                    'error': 'Content-based model not loaded'
                }

            # Check if model is fitted and ready
            model_info = {
                'status': 'healthy',
                'model_type': 'content_based',
                'is_fitted': hasattr(content_model, 'is_fitted') and content_model.is_fitted,
                'features_count': getattr(content_model, 'n_features_', 0),
                'recommendations_generated': getattr(content_model, 'recommendations_count_', 0)
            }

            return model_info

        except Exception as e:
            logger.error(f"Content-based model health check error: {e}")
            return {'error': str(e)}, 500

    def _save_recommendations(self, user_id: int, recommendations: List[Dict], algorithm: str):
        """Save recommendations to database"""
        try:
            for rec in recommendations:
                # Ensure we have a valid recommendation score
                rec_score = rec.get('recommendation_score', rec.get('similarity_score', rec.get('preference_score', 0.8)))
                if rec_score is None:
                    rec_score = 0.8  # Default score

                recommendation = Recommendations(
                    user_id=user_id,
                    workout_id=rec.get('exercise_id'),
                    recommendation_score=float(rec_score),
                    algorithm_used=algorithm,
                    recommendation_type=algorithm,
                    content_based_score=float(rec_score),
                    collaborative_score=0.0,
                    recommendation_reason=f"Content-based recommendation based on exercise similarity"
                )
                recommendation.save()

            logger.info(f"Successfully saved {len(recommendations)} {algorithm} recommendations for user {user_id}")

        except Exception as e:
            logger.error(f"Error saving recommendations: {e}")
            # Don't raise exception, just log - recommendations can still be returned